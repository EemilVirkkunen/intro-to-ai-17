---
  title: Part 3
  exercise_page: true
  quiz_page: false
  published: true
---


<% partial 'partials/exercise', locals: { name: 'Check & Mate! (2p)' } do %>

<p>
  Last week we practiced game algorithms, Minimax and alpha-beta
  pruning, on the simple game of tic-tac-toe. Tic-tac-toe is a good
  choice for understanding the basic principles and simulating the
  algorithms step-by-step. However, it is hardly a very cool
  AI application.
</p>

<p>
  Now we'll change gears and go for what used to be thought as a some
  kind of a "grand challenge" for AI, namely chess! (In fact, that's
  not exactly true since we'll be playing a variant of chess,
  called <a href="https://en.wikipedia.org/wiki/Los_Alamos_chess">Los
    Alamos chess</a> which is played on a 6 x 6 board with no bishops.)
</p>

<p>
  Implementing the complete game engine with all the rules is somewhat
  tedious, so we have done it for you. Also, since you've already
  implemented alpha-beta pruning last week, you don't have to do it
  again here. Instead, your task is to implement a <strong>
    heuristic evaluation function</strong>. The performance of the
  chess bot is in part determined by the goodness of the evaluation
  function, so designing a good one is critical for creating a
  competitive bot.
</p>

<p>
  To make things exciting, we'll have a <strong>chess-bot
  tournament</strong>. You will submit your solution (the heuristic
  evaluation function) on our server and compete against our own
  contender, <i>Deep Glue</i> and bots by other students. May the
  best bot win!
</p>

<ol>
  <li>
    Download the Java template <a href="https://materiaalit.github.io/intro-to-ai-17/files/Chesspackage.zip">here</a>. <strong>NB: There was an error (old version) in the
      package and it was fixed on Sept 21, 4.20pm. If you have problems
      uploading to the server, please reload the new package and try again.</strong>
  <li>
    Implement the method <code>double eval(Position p)</code> in class
    <code>YourEvaluator</code>. The method takes as its input a board
    position <code>p</code> which specifies the positions of all the
    pieces on the board and which player's turn it is. The return value
    should be the higher the more likely the white player is to win.
  <li>
    You can upload the compiled <code>YourEvaluator</code> class
    (i.e., the <code>class</code> file) on
    the <a href="http://ejaasaar.users.cs.helsinki.fi/">tournament
    server</a>. (If you use multiple classes, you can also upload a JAR
    file.)
  <li>
    Once you have uploaded your bot, you can play it against the other
    bots. You gain points by winning and lose points by losing. The
    highest ranked bot will be declared the champion at the end of the
    course. (One week before the exam.)
</ol>

<% end %>

<% partial 'partials/material_heading' do %>
  Probabilistic Inference
<% end %>

<p>
  Let's now move ahead with the theme Reasoning under Uncertainty,
  and see how probability can be used for inference in various
  AI problems.
</p>

<% partial 'partials/material_sub_heading' do %>
  Bayes rule and probabilistic inference
<% end %>

<p>
  Bayes rule has a central role in statistical inference and machine
  learning. The basis for this is that it can be applied in scenarios
  where one of the random variables in the model corresponds to an
  unknown "state" which we are interested to learn. If the model
  includes other variables that correspond to "observations" that
  can be made and that are dependent on the unknown state, we
  can use the Bayes rule as follows
</p>
<img src="/img/drawings/posterior_prior_likelihood.png" width=83% alt="P(state | observation) = P(state) P(observation | state) / P(observation)">
<p>
  The left side of the equation is called the <strong>posterior
  probability</strong> (probability after the observation).
  The first factor on the right is called the <strong>prior
    probability</strong> (probability prior to the observation),
  the middle factor is called the <strong>likelihood</strong>
  (how likely the observation is when the state is given), and
  the last term on the right has many names, of which 
  <strong>the annoying denominator</strong> may be the most
  fitting. (Evidence and marginal likelihood are more
  common.)
</p>

<% partial 'partials/hint', locals: { name: 'On (not) calculating the annoying denominator' } do %>

<p>
  As you may have noticed, when completing last week's exercises,
  and as you will notice at the latest when completing this week's,
  calculating the denominator may indeed be annoying.
</p>

<p>
  A nice trick that can sometimes save a lot of effort is to
  calculate the <strong>ratio</strong> of posterior probabilities,
  instead of the probabilities themselves. For example, consider
  the following ratio
</p>
<pre>
     R = P(State=1 | obs) / P(State=2 | obs)
</pre>
<p>
  where <code>obs</code> is an abbreviation for observation. 
  Applying Bayes rule to both the numerator and the denominator
  in the ratio, we'll notice that the denominator <code>P(obs)</code>
  cancels:
</p>
<pre>
     P(State=1) P(obs | State=1) / P(obs)   P(State=1) P(obs | State=1)
R =  ------------------------------------ = ---------------------------
     P(State=2) P(obs | State=2) / P(obs)   P(State=2) P(obs | State=2)
</pre>
<p>
  In case the two states (1 and 2) are the only possibilities, we
  have <code>P(State=2|obs) = 1-P(State=1|obs)</code> (because one of
  the events must happen and both cannot occur at the same time).
  In this case, after calculating the the above ratio, <code>R</code>,
  it can be mapped back into the posterior probability of state 1 by
</p>
<pre>
  P(State=1 | obs) = R / (1+R)
</pre>
<p>
  You can check that this is true by assigning and using the
  fact <code>P(State=2|obs) = 1-P(State=1|obs)</code>.
</p>

<% end %>

<% partial 'partials/material_sub_heading' do %>
  Naive Bayes classification
<% end %>

<p>
  One of the most useful applications of the Bayes rule is the so
  called <strong>naive Bayes classifier</strong>. It is a machine
  learning technique that can be used to <strong> classify</strong>
  objects such as text documents into two or more classes. The
  classifier is trained by analysing a set of <strong>training
  data</strong>, for which the correct classes are given.
</p>

<p>
  The naive Bayes model is a probabilistic model that involves a class
  variable -- this corresponds to the state variable above -- and a
  number of feature variables. The assumption in the model is that the
  feature variables are <strong> conditionally independent</strong>
  given the class.  (We will not discuss the exact meaning of
  conditional independence on this course. You can find more about it
  from the literature. For our purposes, it is enough to be able to
  exploit conditional independence in building the classifier.)
</p>

<p>
  We will use a <strong>spam email filter</strong> as a running
  example for illustrating the idea of the naive Bayes
  classifier. Thus, the class variable indicates whether a message is
  spam (or "junk email") or whether it is a legitimate message (also
  called "ham").  The words in the message correspond to the feature
  variables, so that the number of feature variables in the model
  is determined by the length of the message.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Estimating parameters
<% end %>

<p>
  To define the naive Bayes model, we need to specify the distribution
  of each variable. For the class variable, this is the distribution
  of spam vs ham messages, which we can for simplicity assume to be
  1:1, i.e., <code>P(spam) = P(ham) = 0.5</code>.
</p>

<p>
  For the feature variables, we will define two distributions: one for
  the spam messages and another one for the ham messages. In each case,
  we will make the simplifying assumption that each of the words in the
  message is distributed according to the same distribution. And as we
  said above, we also assume that the words are independent of each 
  other given the spam/ham class.
</p>

<p>
  The word distributions for the two classes are
  best <strong>estimated</strong> from actual training data, i.e., a
  corpus of spam messages and a corpus of legitimate messages. The
  simplest way is to count how many times each word, <code>aardvark,
  aardwolf, ..., Zyzzogeton</code>, appears in the corpus and dividing
  the number by the total number of words in the corpus.
</p>

<p>
  To illustrate the idea, let's assume that we have at our disposal
  both a spam corpus and a ham corpus. You can easily obtain one
  by saving a batch of your emails in two files.
</p>

<p>
  Assume that we have calculated the number of occurrences of the
  following words in the two classes of messages:
</p>
<pre>
        word    spam     ham
 ----------- ------- -------
 million         156      98
 dollars          29     119
 adclick          51       0
 conferences       0      12
 ----------- ------- -------
       total   95791  306438
</pre>

<% partial 'partials/hint', locals: { name: 'Watch out for the Singularity!' } do %>

<p>
  One problem with estimating the probabilities directly from the
  counts is that the zero counts lead to zero estimates. This can be
  quite harmful for the performance of the classifier -- it easily
  leads to situations where the ratio of the posterior probabilities
  obtained as 0/0. That sounds dangerously close to the Singularity,
  so we'd better find a better way. The simplest solution is to use a
  small lower bound for all probability estimates. The value 0.000001,
  for instance, does the job.
</p>

<% end %>

<p>
  We can now estimate that the probability that a word in a spam
  message is <code>million</code>, for example, is about 156/95791
  &asymp; 0.0016285. In other words, on the average, roughly every
  614th word in a spam message is <code>million</code>. Likewise, we
  get the estimate 0.0003198 for the probability that a word in a ham
  message is <code>million</code>. Both of these probability estimates
  are small but more importantly, the former is higher than the
  latter. This turns out to be a sign that the word in question hints
  towards the message being spam -- which sounds logical. Words for
  which the ratio of the probabilities is the other way around, hint
  towards the message being ham.
</p>

<% partial 'partials/material_sub_sub_heading' do %>
  Classifying new data
<% end %>

<p>
  After the parameters of the model have been estimated, the
  classifier is ready for use! When we are given a new message, we
  will compute the posterior probability <code>P(spam |
  message)</code>, where <code>message</code> is a place-holder for
  the words in the message, for example, <code>P(spam | 'million',
  'conferences')</code> (which would be a really short message).
</p>

<p>
  Let's compute the posterior probability
</p>
<pre>
     P(spam | Word1 = 'million', Word2 = 'conferences')
</pre>
<p>
  which is abbreviated without a great risk of confusion -- but please
  note that unlike <code>million</code> and <code>conferences</code>,
  which are hyphenated ('like this') to indicate that they are words that occur
  in the message, the term <code>spam</code> indicates
  the <i>class</i> of the message, not the word "spam" -- as
</p>
<pre>
     P(spam | 'million', 'conferences')
</pre>
<p>
  By Bayes rule, we have
</p>
<pre>
                                      P(spam) P('million', 'conferences' | spam)
 P(spam | 'million', 'conferences') = ------------------------------------------
                                            P('million', 'conferences')
</pre>
<p>
  The numerator on the right side is the likelihood term and its meaning
  is the probability that the first two words are <code>million</code>
  and <code>conferences</code> given that the message is spam. The
  denominator on the right side -- it's the annoying one -- is the
  probability that the first two words are as stated when the spam/ham
  status of the message is <strong>not</strong> given.
</p>

<p>
  Let's look at the likelihood term first. The conditional independence
  assumption, i.e., the naive Bayes assumption, implies that the
  likelihood can be "factorized" as follows
</p>
<pre>
  P('million', 'conferences' | spam) = P('million' | spam) P('conferences' | spam)
</pre>
<p>
  This is very useful since these are the kind of probabilities we
  have estimated from the data. The same factorization rule can be
  applied no matter how many words there are in the message.
</p>

<p>
  Next up is the annoying denominator. However, we'll use the hint above
  and avoid calculating the denominator (at least explicitly). To achieve
  this, we consider the ratio of posteriors:
</p>
<pre>
 P(spam | 'million', 'conferences')   P(spam) P('million', 'conferences' | spam) / Z
 ---------------------------------- = ----------------------------------------------
  P(ham | 'million', 'conferences')    P(ham) P('million', 'conferences' | ham) / Z
</pre>
<p>
  where Z, defined as <code>Z = P('million', 'conferences')</code>,
  is the annoying denominator which cancels out just as promised in the hint.
</p>

<p>
  The term <code>P('million', 'conferences' | ham)</code> is treated in the exact
  same manner as the term corresponding term for spam (see above), and the
  numbers required to calculate its value are available since we have
  estimated them from the training data.
</p>

<p>
  The following exercises will demonstrate the use of the naive Bayes
  model.
</p>

<% partial 'partials/exercise', locals: { name: 'Naive Bayes and Spam (pencil-and-paper) (2p)' } do %>

<p>
  Consider the word counts given in the table above (million, dollars, <i>etc</i>).
</p>
<ol>
  <li>
    Estimate the remaining word probabilities for both classes.
  <li>
    Use the obtained estimates to calculate the probability
    <code>P(Word &ne; 'million')</code>, i.e., the probability that
    a single word in a message is <i>not</i> <code>million</code> when
    the class of the message is unknown. <i>Hint:</i> You should recall
    the rule for calculating the <b>marginal probability</b>
    (see, for example, the references given under Section 3.1
    Probability Fundamentals of Part 2).
  <li>
    Calculate <code>P(spam | 'million')</code>, i.e., the probability
    that the message is spam given that its first word (or in fact,
    any particular word) is <code>million</code>.
  <li>
    Calculate <code>P(spam | 'million', 'dollars', 'adclick', 'conferences')</code>,
    i.e., the probability that the message is spam when its first four
    words are as stated.
</ol>
<p>
  Use the prior probability <code>P(spam) = 0.5</code>.
</p>
<p>
  <i>Additional hints:</i> In item 3, remember Bayes. In item 4, remember
  to use a lower bound on the estimates. Also recall the trick about
  not calculating the annoying denominator.
</p>

<% end %>

<% partial 'partials/material_sub_sub_heading' do %>
  Implementation details
<% end %>

<p>
  The above exercise should make it relatively straightforward to see
  how the filter can be implemented by programming: the key insight is
  the routine nature of the word-by-word calculations.
</p>

<p>
  A convenient way to group the computations is obtained by slight
  reshuffling of the terms. Consider still our example two-word message,
  and the following formula for the ratio of the posterior probabilities
</p>
<pre>
     P(spam | 'million', 'conferences') 
 R = ----------------------------------  
      P(ham | 'million', 'conferences')

     P(spam) P('million' | spam) P('conferences' | spam)
   = ---------------------------------------------------
       P(ham) P('million' | ham) P('conferences' | ham)
</pre>
<p>
  Since the ratio of products is equal to the product of ratios -- i.e.,
  for example, (ABC)/(DEF) = (A/D)(B/E)(C/F) -- we can group the above terms as
</p>
<pre>
     P(spam)  P('million' | spam)  P('conferences' | spam)
 R = -------  -------------------  -----------------------
     P(ham)   P('million' | ham)   P('conferences' | ham)
</pre>
<p>
  More generally, the formula is
</p>
<pre>
       P(spam)  N  P(word_i | spam)
   R = -------  &Pi;  ----------------
       P(ham)  i=1 P(word_i | ham)
</pre>
<p>
  where N is the number of words in the message, and <code>word_i</code> is the
  i'th word in the message.
</p>

<p>
  Intuitively, the above formula encodes the rule that any word whose
  probability is higher in spam messages than in ham messages will
  increase the ratio R, and vice versa. For example, in our two-word
  message, for <i>i</i>=1, we have <code>word_i =
  'million'</code>, and the ratio of the word probabilities is
  given by
</p>
<pre>
    P(word_1 | spam)   P('million' | spam)   0.0016285
    ---------------- = ------------------- &asymp; --------- &asymp; 5.1 
    P(word_1 | ham)    P('million' | ham)    0.0003198
</pre>
<p>
  Thus, each occurrence of the word <code>'million'</code> in the message
  leads to roughly a five-fold increase in the posterior probability ratio.
</p>

<p>
  Putting things together, here's a pseudocode sketch of the classification
  stage where we assume that the probability estimates have already been
  calculated from training data.
</p>

<% partial 'partials/code_highlight' do %>
1:  spamicity(words, estimates):
2:     R = estimates.prior_spam / estimates.prior_ham
3:     for each w in words:
4:        R = R * estimates.spam_prob(w) / estimates.ham_prob(w)
5:     return R
<% end %>

<p>
  Here <code>estimates</code> is an object that stores the estimated
  probabilities: <code>estimates.prior_spam</code> is the probability that
  a message is spam, P(spam), <code>estimates.prior_ham</code> the same
  for ham; <code>estimates.spam_prob(w)</code> is the probability
  <code>P(Word = w | spam)</code>, and <code>estimates.ham_prob(w)</code>
  the same for ham.
</p>

<% partial 'partials/hint', locals: { name: 'Avoiding under- and overflows' } do %>

<p>
  When dealing with long messages, the posterior probability ratio becomes
  a product with very many terms. This can easily lead to trouble because
  products are creatures that easily grow very very large or very very small
  (close to zero); the mathematical term is 'exponential rate'.
</p>

<p>
  In order to reduce the risk of under- and overflows in the floating
  point arithmetics, it is a good idea to carry out the computations
  in log-scale.  That is, instead of computing the ratio, R, you
  should compute its logarithm, log(R). (Store the log-ratio in a variable
  like <code>logR</code>.)
</p>

<p>
  The important thing to recall about logarithms is that they convert
  multiplication into addition: log(AB) = log(A) + log(B); and similarly,
  division becomes subtraction: log(A/B) = log(A) &ndash; log(B). Using these,
  we can write the log-ratio as
</p>
<pre>
                                       N
   logR = log(P(spam)) - log(P(ham)) + &Sigma; [log(P(word_i | spam)) - log(P(word_i | ham))]
                                      i=1
</pre>
<p>
  The base of the logarithm (natural, 2, 10, ...) is not
  consequential. The important thing is to map the end result back to
  the ratio by exponentiating the log-ratio with the same base. So if
  you use natural logarithms, for instance, then you should
  exponentiate the log-ratio by <code>exp(logR)</code> to get R.
</p>

<% end %>

<% partial 'partials/exercise', locals: { name: 'Naive Bayes and Spam (programming) (2p)' } do %>

<p>
  Next you get to implement a naive Bayes spam filter by
  programming. The Java template is available on TMC. (In case you
  prefer to use another programming language, feel free to. You can
  find the ready-made spam and ham word count
  files, <code>spamcount.txt</code> and <code>hamcount.txt</code> in
  the template.)
</p>

<p>
  <ol>
    <li>
      Download the template and take a look at the word count files in
      the template, which originally come from the development team of
      the <a href="http://spamassassin.apache.org/">SpamAssassin</a>
      spam filter. The common "stop-words" that are uninteresting for
      our present purpose, such as <i>the, a, to, ...</i> have been
      removed, as have words that occur only once. The files are
      sorted so that the most common words in the respective class
      come first:
      <pre>

	top 10 spam words: top 10 ham words:
        ------------------ -----------------
         624 free          1776 list
         465 email         1263 lists
         414 money         1204 use
         410 please        1007 exmh
         410 mail           987 like
         383 list           952 some
         360 click          919 wrote
         358 content        909 linux
         339 business       895 listinfo
         306 information    893 rpm
      </pre>
      The total number of unique words in the spam messages is 6245, and the
      total word count is 75268. The ham messages have 16207 unique words and
      the total word count is 290673.
    <lI>
      Estimate the conditional probabilities <code>P(Word=s | spam)</code>
      and <code>P(Word=s | ham)</code> for all words <code>s</code> that occur
      in the files. For example, you should get the estimate <code>P('free' | spam)</code>
      &asymp; 0.00829.
    <li>
      Now implement a filter that reads a new message and calculates the probability
      that it is spam using the naive Bayes model, following the instructions
      above.
  </ol>
</p>

<p>
  <i>Hints:</i> In item 3, you may encounter words that you haven't 
  encountered in the training data at all. You can use the small constant
  lower bound for them.
</p>

<% end %>
